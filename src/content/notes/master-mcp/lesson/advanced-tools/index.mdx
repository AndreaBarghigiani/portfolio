---
title: Advanced Tools
course: master-mcp
module: advanced-mcp-features
order: 1
description: Let's learn how to leverage the annotations and structured output to help clients and users better understand how out tool will behave.
---
import EL from '@/components/ui/ExternalLink.astro';

In this lesson we will learn about two ways that let us help our users and clients. With the first section we will learn how to leverage `annotations`, a set of standard properties that we can turn on and off to signal, generally with warnings, what the tool the user is about to use is capable of.

Later we will move our interest in the Structured Output, a property that still lives inside our tool definition with the key of `outputSchema`. As the name suggests, this is another feature at our disposal that allow us to prepare the LLM about the type of information the tool is able to return.

# Tool Annotations 
Let's start to learn how to properly use the `annotations`, a special key that is always been present inside the `config`  section of a `registerTool` call.

Since I like, a lot, the way TS helps us understand the signature of the code we get from libraries, here's the definition of this part of the configuration:
```ts
type ToolAnnotations = {
  title?: string;
  readOnlyHint?: boolean;
  destructiveHint?: boolean;
  idempotentHint?: boolean;
  openWorldHint?: boolean;
  [key: string]: any; // ‚Üê This is from "passthrough"
}
```
As we can see we have five defined properties that we can use, even though the Zod schema allows the user to define (and keep after the validation process) custom keys.

Each one of this properties has a specific meaning and while the language used by the documentation is not accurate, here I'll try to give you some guidance. But before that, let's answer the question: *"Why do they exist?"*
- **UX clarity**: with their presence users understand better what a tool can do before approving its use.
- **Safety**: the tool can warn about potentially destructive or open-world actions.
- **Automation**: the clients can group, filter or require extra approval for certain tools.

| Annotation | Default | Description | Relevance |
| --- | --- | --- | --- |
|`readOnlyHint`|`false`|if true, the tool does not modify its environment.|Always relevant|
|`destructiveHint`|`true`|If true, the tool may perform destructive updates to its environment.|Irrelevant when `readOnlyHint` is true|
|`idempotentHint`|`false`|If true, calling the tool repeatedly with the same arguments will have no additional effect on its environment.|Irrelevant when `readOnlyHint` is true|
|`openWorldHint`|`true`|If true, this tool may interact with an "open world" of external entities (outside of the tool's domain).|Always relevant|

### Pragmatic Annotation Guidelines
For practical tool design, consider these guidelines:
- Use `destructiveHint: true` for tools that **delete** records or data
- Use `destructiveHint: false` for tools that **modify** content (even if original is overwritten).
- Use `idempotentHint: true` for tools that produce the same logical result regardless of call count. Ignore metadata changes (timestamps, access logs, etc.). Focus on the core operation outcome.
- Use `idempotentHint: false` for tools that produce a different result each time they are called.
- Use `openWorldHint: true` for tools that interact with systems external to your application.

At the time of writing these are all the annotations available, but to stay up to date with new ones and read their definitions <EL href="https://modelcontextprotocol.io/specification/2025-06-18/schema#toolannotations">use the specs</EL>.
# Structured output
When using a structured output we can return rich, machine-validated data instead of plain text. With the `outputSchema` the server ensures that all tool responses conform to a specific structure, making it easier for clients and LLMs to consume, validate and act on the results. 

There's nothing more to say because you'll be the one deciding on the structure of the output generated by the tool.

Once the tool get's called, it'll be the server in charge of validating the output its generating against the schema even before it'll be returned to the client. At this point the clients and LLMs can parse and use the structured result and if the output does not match your server will be able to return an error and let them handle.

## Step 1: Annotations
In this lesson there's much to say about, we went through al the tools we had in `tools.ts` and populated `annotation` accordingly while strength our knowledge of the possible values.

## Step 2: Structured Output
Providing an `outputSchema` allow LLMs, clients and also the users to know **in advance** the structure of what a specific tool returns.

This is powerful because allows, especially the LLMs, which kind of properties they will get in return from a specific tool.

One thing that I didn't get at first is that defining only a `outputSchema` inside our config object **is not enough** to make it work properly.

Let's run first a little refresher on how it is structured our `registerTool` call. You can find all the details in <EL href="/notes/master-mcp/lesson/tools/">the dedicated notes</EL> but for this one the following will be enough:
```ts
registerTool({
  name: "name_your_tool",
  // Config object
  {
    title: "Readable name",
    description: "Give more context",
    annotations: {}, // Hints about what the tool is capable
    inputSchema: {}, // Optional, to be define if the tool accepts inputs
    outputSchema: {}, // This is the focus of this step! 
  },
  // The callback, where the magic happens
  (args) => {}
})
```
Reading it like that you can think: *"Alright, we have to define an `outputSchema`, where's the news?*

And you could do the same mistake as I did in the first place because defining `outputSchema` is just a part of the feature!

Now that we told our tool what shape of output it has to provide, its time to **make it happen** right inside the object that our tool returns.

This is because as soon as you define an `outputSchema` inside the config object you **have to define a `structuredContent` object** that matches the schema right inside the `return` of your callback.

So, back to the lesson, the first tool we encounter where we have to define an `outputSchema` is the `create_entry` tool:
```ts
agent.server.registerTool(
	'create_entry',
	{
		title: 'Create Entry',
		description: 'Create a new journal entry',
		annotations: { /* We populate it in the previous step */},
		inputSchema: createEntryInputSchema, // Kent provides this
		outputSchema: { /* We need to populate this! */ }, 
	},
	async (entry) => {
		// We will get back to this...
	},
)
```
For obvious reason I kept the code as short as possible, as you can see there are some part commented out (well removed), but let's focus on the `outputSchema` as is the topic for this lesson step.

We have to populate it, and Kent's provide an `entryWithTagsSchema`, but which shape has it?

```ts
export const entrySchema = z.object({
	id: z.coerce.number(),
	title: z.string(),
	content: z.string(),
	mood: z.string().nullable(),
	location: z.string().nullable(),
	weather: z.string().nullable(),
	isPrivate: z.coerce.number(),
	isFavorite: z.coerce.number(),
	createdAt: timestampSchema,
	updatedAt: timestampSchema,
})

export const entryWithTagsSchema = entrySchema.extend({
	tags: z.array(z.object({ id: z.number(), name: z.string() })),
})
```
Once more, reading Kent's code is really important because we discover so many good practices!

For example, in order to not repeat himself (since he'll need the same shape for other schemas), Kent created an `entrySchema` that defines the structure of a standard entry. Then he creates the `entryWithTagsSchema` because he wants to `extend` it with the addition of a new `tags` key that holds an array of objects with `id` and `name` properly typed.
```ts
export const entryWithTagsSchema = z.object({
  id: z.coerce.number(),
  title: z.string(),
  content: z.string(),
  mood: z.string().nullable(),
  location: z.string().nullable(),
  weather: z.string().nullable(),
  isPrivate: z.coerce.number(),
  isFavorite: z.coerce.number(),
  createdAt: timestampSchema,
  updatedAt: timestampSchema,
  tags: z.array(z.object({ id: z.number(), name: z.string() })),
});
```
We could have written the schema for an entry with tags as just shown but we would've lost the ability to import the standard schema for an entry everywhere we needed.

> Be aware that since Zod 4 the team has deprecated the `.merge()` method (similar to `.extend()`), but it <EL href="https://zod.dev/v4/changelog#extend">also advice **against** the use of `.extend()`</EL> in favour of a more efficient spread operator. So the following:
> ```ts
> const DogWithBreed = Dog.extend({
  breed: z.string(),
});
> ```
> Becomes:
> ```ts
> const DogWithBreed = z.object({
  ...Dog.shape,
  breed: z.string(),
});
> ```

So long story short what could've been a long `outputSchema` declaration, now is as simple as the following:
```ts
agent.server.registerTool(
  'create_entry',
  {
    title: 'Create Entry',
    description: 'Create a new journal entry',
    annotations: { /* We populate it in the previous step */ },
    inputSchema: createEntryInputSchema, // Kent provides this
    outputSchema: { entry: entryWithTagsSchema },
  },
  async (entry) => {
    // We will get back to this...
  }
);
```
Obviously this will work as long as you remember to import `entryWithTagsSchema` üòÖ

But why do we have to create a new object with the `entry` key? Wouldn't it `entryWithTagsSchema` be enough to tell to the client and LLM the shape of the object?

Well this depends from **what you're returning from the callback**.

Let's focus on that now.
```ts
agent.server.registerTool(
  'create_entry',
  {
    /* We just discussed about it */
  },
  async (entry) => {
    // Creates an entry
    const createdEntry = await agent.db.createEntry(entry);

    if (entry.tags) {
      // Create tags for the entry
    }

    // This is what we're talking about!
    const structuredContent = await agent.db.getEntry(createdEntry.id);

    return {
      // We'll analyzi it later
    };
  }
);
```
Our callback get's and `entry` that has the same shape of the `inputSchema` defined in the config object we discussed earlier.

Now the function takes the `entry` and creates it inside our DB (with a bunch of `tags` that has found), but the cool part comes next.

We **create** a variable `structuredContent` by querying our database for the resource we just created! What looks like a waste of resources at first sight, because depending on your BE config you could've just return the created object, it is **a necessity** because relying on `createdEntry` alone would've miss all the tags that we added later.

So now we have the `structuredContent`, what we do with it?

Well, as I hinted a little before, we just `return` it inside the object!
```ts
agent.server.registerTool(
  'create_entry',
  {
    /* We just discussed about it */
  },
  async (entry) => {
    // Creates an entry
    const createdEntry = await agent.db.createEntry(entry);

    if (entry.tags) {
      // Create tags for the entry
    }

    // This is what we're talking about!
    const structuredContent = await agent.db.getEntry(createdEntry.id);

    return {
      structuredContent,
      content: [ ... ],
    };
  }
);
```
As you can see, `structuredContent` is just another prop for the object that our callback returns.

But that's something more that you can do here, you can also help the LLP by providing the same `structuredContent` right inside the `content` array. 

You read that right, while <EL href="https://modelcontextprotocol.io/specification/2025-06-18/server/tools#structured-content">docs show us</EL> that we are just fine with the insertion of `structuredContent` inside the `return` of our callback, we can provide even more informations within the array that holds all the content that we're returning and it's also a good practice for backwards compatibility.

As I highlighted at the end of the <EL href="/notes/master-mcp/lesson/resources-tools/">Resource in Tools note</EL>, Kent is providing us some utility functions that help our work by abstracting away some object creation logic.

- `createText` help us quickly create a `{type: 'text', ...}` object to quickly output a simple response
- `create<Entry|Tag>ResourceLink` creates a `{type: 'resource_link', ...}` object that allow use to provide links to additional resources
- `create<Entry|Tag>EmbeddedResource` creates a `{type: 'resource', ...}` object that helps us embed a specific resource inside our response

This approach is incredibly helpful, as I stated early its the reason I felt in love in programming in the first place: *abstract away common and repeatable action gives me a high level of satisfaction*.

I mentioned this, because we can leverage these same functions right inside `content`! 
```ts
agent.server.registerTool(
  'create_entry',
  {
    /* We just discussed about it */
  },
  async (entry) => {
    // Creates an entry
    const createdEntry = await agent.db.createEntry(entry);

    if (entry.tags) {
      // Create tags for the entry
    }

    // This is what we're talking about!
    const structuredContent = await agent.db.getEntry(createdEntry.id);

    return {
      structuredContent,
      content: [
        createText(
          `Entry "${createdEntry.title}" created successfully with ID "${createdEntry.id}"`
        ),
        createEntryResourceLink(createdEntry),
        createText(structuredContent),
      ],
    };
  }
);
```
Here we go, we provided `structuredContent` from our tool, so now our clients are able to validate the response and the LLM has all the information that it needs to better handle the data our tool provides.

### Recap
So in closing, in this lesson we learned a ton of new concepts.

**Annotations:**
- little hints that we can provide to let the user know the kind of actions our tool can take
- these do not apply security measure, but help the user decide if he wants to move forward with the tool
- just add them in the configuration object of the tool and you're fine (in the end it sits at the same level of `title`, `description`, `inputSchema` and `outputSchema`)

**Structured Content:**
- we can provide a schema that will validate the output of our tool inside the `outputSchema` of the configuration object of the tool
- we are free to generate the JSON object as we wish, as long as it respect the schema
- we inject the JSON object of our structured content within the `structuredContent` key of the returned object
- to increase backward compatibility we should return the serialized JSON inside the returned `content` array 